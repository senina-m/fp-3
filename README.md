## <center> Национальный исследовательский университет информационных технологий, механики и оптики </center> 
### <center> Факультет Программной Инженерии и Компьютерной Техники </center> 
----
 <br /> 
 <br />
 <br />

## <center> Лабораторная работа 3 </center>

### <center>«Функциональное программирование»</center>

<div style="text-align: right"> 

Работу выполнила:

Студентка группы P3212

Сенина Мария Михайловна

Преподаватель:

Пенской Александр Владимирович
</div>


<center>Санкт-Петербург</center>
<center>2023</center>

<div style="page-break-after: always; visibility: hidden">pagebreak</div>

# Цель
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой.

# Задание
В рамках лабораторной работы вам предлагается повторно реализовать лабораторную работу по предмету "Вычислительная математика" посвящённую аппроксимации (в разные годы это лабораторная работа 3 или 4) со следующими дополнениями:

- обязательно должна быть реализована линейная интерполяция (отрезками, [link](https://en.wikipedia.org/wiki/Linear_interpolation));
- настройки алгоритма аппроксимирования и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример -- `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:

```text
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +------------------------+      +------------------------------+
    | алгоритм аппроксимации |<-----| генератор точек, для которых |
    +------------------------+      | необходимо вычислить         |
            |                       | аппроксимированное значение   |
            |                       +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:

```text
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- `o` -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре аппроксимации" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- `x` -- точки, расчёт которых для "окон" не требуется.

# Требования
* программа должна быть реализована в функциональном стиле;
* ввод/вывод должен быть отделён от алгоритмов аппроксимации;
* требуется использовать идиоматичный для технологии стиль программирования.

# Реализация

#### Вся программа состоит из 4х пакетов-модулей:

[Пакет потокового чтения данных из файла](/src/input.lisp)

[Пакет интрополяции линейным методом](/src/line.lisp)

[Пакет интрополяции методом Лагранжа](/src/lagrange.lisp)

[Пакет с функцией входа и управлением вычислениями](/src/lagrange.lisp)

#### Поток вычисления в программе такой:

```cl
(defun main (win-size filename &key (line nil) (lagrange nil))
  """Интрополяция потока точек"""
  (format t "line=~a~%" line)
  (format t "lagrange=~a~%" lagrange)
  (format t "win size=~a~%" win-size)
  (if (/= (mod win-size 2) 0) (format t "Can't find middle of odd window")
    (progn (input:open-file filename)
           (let ((win nil))
             (loop :for l = (input:get-line)
                   :until (eq l :eof)
                   :do (handler-case
                           (progn (setf win (push-line win l win-size))
                                  (when (= (length (first win)) win-size)
                                    (multiple-value-bind (x-list y-list point) (make-arrays-from-win win)
							 (when line (format t "line-appr: (~a ~a)~%" point (line:appr-line x-list y-list point)))
							 (when lagrange (format t "lagrange-appr: (~a ~a)~%" point (lagrange:appr-lagrange x-list y-list point))))))
                         (push-line-fault (pe) (format t "~a~%" (push-line-fault-text pe))))))
           (input:close-file))))
```

# Заключение
В этой лабораторной работе я лучше познакомилась с математической "обвеской" языка lisp научилась здесь работать с массивами. 
И лучше разобралась с работой пакетов и экспортов функций. Также я опробовала механизм сигналов для "отлова" ошибок и способами работы с возникшими ошибками.
