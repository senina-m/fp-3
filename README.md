## <center> Национальный исследовательский университет информационных технологий, механики и оптики </center> 
### <center> Факультет Программной Инженерии и Компьютерной Техники </center> 
----
 <br /> 
 <br />
 <br />

## <center> Лабораторная работа 3 </center>

### <center>«Функциональное программирование»</center>

<div style="text-align: right"> 

Работу выполнила:

Студентка группы P3212

Сенина Мария Михайловна

Преподаватель:

Пенской Александр Владимирович
</div>


<center>Санкт-Петербург</center>
<center>2023</center>

<div style="page-break-after: always; visibility: hidden">pagebreak</div>

# Цель
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой.

# Задание
В рамках лабораторной работы вам предлагается повторно реализовать лабораторную работу по предмету "Вычислительная математика" посвящённую аппроксимации (в разные годы это лабораторная работа 3 или 4) со следующими дополнениями:

- обязательно должна быть реализована линейная интерполяция (отрезками, [link](https://en.wikipedia.org/wiki/Linear_interpolation));
- настройки алгоритма аппроксимирования и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример -- `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:

```text
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +------------------------+      +------------------------------+
    | алгоритм аппроксимации |<-----| генератор точек, для которых |
    +------------------------+      | необходимо вычислить         |
            |                       | аппроксимированное значение   |
            |                       +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:

```text
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- `o` -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре аппроксимации" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- `x` -- точки, расчёт которых для "окон" не требуется.

# Требования
* программа должна быть реализована в функциональном стиле;
* ввод/вывод должен быть отделён от алгоритмов аппроксимации;
* требуется использовать идиоматичный для технологии стиль программирования.

# Реализация

#### Вся программа состоит из 4х пакетов-модулей:

[Пакет потокового чтения данных из файла](/src/input.lisp)

[Пакет интрополяции линейным методом](/src/line.lisp)

[Пакет интрополяции методом Лагранжа](/src/lagrange.lisp)

[Пакет с функцией входа и управлением вычислениями](/src/lagrange.lisp)

#### Поток вычисления в программе такой:

![workflow](/diagrams/workflow.png "Процесс выполнения")

Получая данные из файла строчка за строчкой мы проверяем, что получили корректную строку.

Далее в зависимости от указанных аргументов запускаем ту или иную интрополяцию.


```cl
(defun main (win-size filename &key (line nil) (lagrange nil))
  """Интрополяция потока точек"""
  (format t "line=~a~%" line)
  (format t "lagrange=~a~%" lagrange)
  (format t "win size=~a~%" win-size)
  (if (/= (mod win-size 2) 0) (format t "Can't find middle of odd window")
    (progn (input:open-file filename)
           (let ((win nil))
             (loop :for l = (input:get-line)
                   :until (eq l :eof)
                   :do (handler-case
                           (progn (setf win (push-line win l win-size))
                                  (when (= (length (first win)) win-size)
                                    (multiple-value-bind (x-list y-list point) (make-arrays-from-win win)
							 (when line (format t "line-appr: (~a ~a)~%" point (line:appr-line x-list y-list point)))
							 (when lagrange (format t "lagrange-appr: (~a ~a)~%" point (lagrange:appr-lagrange x-list y-list point))))))
                         (push-line-fault (pe) (format t "~a~%" (push-line-fault-text pe))))))
           (input:close-file))))
```
Большинство функций в проекте задокументированно в коде, поэтому не буду их тут расписывать. 

### Пример исполнения

Входной файл
```
9 2
3 10
1 2
3 4
5 6
7 8
9 10
11 12
13 14
15 16
17 18
19 20
```

```
* (main 3 "input" :line t :lagrange t)
line=T
lagrange=T
win size=3
Can't find middle of odd window
NIL
```

```
* (main 4 "input" :line t :lagrange t)
line=T
lagrange=T
win size=4
line number:0

((2) (9)) 
line number:1

((3 2) (10 9)) 
line number:2
x(1) value in numbers pair has to be greater than last x(3) value in window
NIL
line number:3
x(3) value in numbers pair has to be greater than last x(3) value in window
NIL
line number:4

((5 3 2) (6 10 9)) 
line number:5

((7 5 3 2) (8 6 10 9)) 
line-appr: (4 8)
lagrange-appr: (4 83/10)
line number:6

((9 7 5 3) (10 8 6 10)) 
line-appr: (6 7)
lagrange-appr: (6 53/8)
line number:7

((11 9 7 5) (12 10 8 6)) 
line-appr: (8 9)
lagrange-appr: (8 9)
line number:8

((13 11 9 7) (14 12 10 8)) 
line-appr: (10 11)
lagrange-appr: (10 11)
line number:9

((15 13 11 9) (16 14 12 10)) 
line-appr: (12 13)
lagrange-appr: (12 13)
line number:10

((17 15 13 11) (18 16 14 12)) 
line-appr: (14 15)
lagrange-appr: (14 15)
line number:11

((19 17 15 13) (20 18 16 14)) 
line-appr: (16 17)
lagrange-appr: (16 17)
line number:12
T
```

# Заключение
В этой лабораторной работе я лучше познакомилась с математической "обвеской" языка lisp научилась здесь работать с массивами. 
И лучше разобралась с работой пакетов и экспортов функций. Также я опробовала механизм сигналов для "отлова" ошибок и способами работы с возникшими ошибками.
